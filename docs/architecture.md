# Architecture

[Common Terms](#common-terms) - [Frontend](#frontend-react) - [Session Service](#session-service) - [Hotkey System](#hotkey-serviceproviders) - [Timer](#timer)

---

<img width="500" src="images/osa.png" alt="architecture" />

---

### Common Terms
* Session
  * Primary user interface with underlying system
  * Manages user input via exported Go functions in SessionService
  * Keep up with the loaded split file, timer, and hotkey bindings
  * Contains:
    * Loaded split file
    * Current Segment
    * Timer Service
    * Hotkey Service
* Split File
  * Primary data store for a user to store per-game/category data
  * Saved as JSON (with extension *.osf)
  * Contains:
    * Game Name
    * Game Category
    * Number of Attempts
    * List of Segments
* Segment
  * A part of a run that comprises a speedrun.
  * Contains:
    * ID 
    * Segment Name (e.g. "Level 1")
    * Segment Best Time
    * Segment Average Time

#### Payloads
All of these have "payloads" which are just exported versions that are sent to the
frontend/filesystem and are generated with the `.getPayload()` method of the given struct.

If you need to send or retrieve data from the frontend, you'll do it via these Payloads, never the actual struct internals themselves,
they are not exported and therefore unavailable to the frontend.

For example, if my frontend wants to load and edit a split file, it'll call the `LoadSplitFile`
typescript method generated by Wails. Go will then load the splitfile, create a payload representing it with .getPayload(),
and then send that payload to the typescript system.

Once edits are made to the payload, it will send it back via the `UpdateSplitFile` typescript method
with the modified payload as the parameter.  The Go backend will then take that payload, read it, and apply
changes to its underlying internally loaded split file.  The internals are never directly manipulated by
typescript, they are not exported members of the structs.

The method binding from Go to Typescript is covered below.

### Frontend (React)
Users interact with the frontend React system.  This works essentially like any other React application with tsx/ts files powering it.
If you know how to write a React application, the code is exactly the same.

Communication with the backend should always flow through the Session Service unless there is a compelling reason to bypass it.  This single source
I/O between frontend and backend should remain as simple as possible, hiding as much complexity as possible in the backend services.

Communication with the session service can be done imperatively via Javascript bindings, or event based via the `EventsOn` API generated by Wails.
Wails will generate a Javascript function for every Exported (public, starts with capital letter) Go function in any struct passed into the 
`Options.App -> Bind` member slice passed into Wails.Run in `main.go`; it will also generate any TypeScript types needed to call the methods 
it generates in frontend/Wails/go/models.ts.  This method will return a Promise<Go Return Type>, so await it or chain it as needed.    

#### Binding Example
```go

// main.go
type Test struct {
  ctx context.Context
}
func (t *Test) HelloWorld() (string, error) { return "Hello World!", nil }
func (t *Test) startup(ctx context.Context) {
  // If your binding needs to work with Wails platform (e.g. Open a Save File Dialog)
  // you need to have a startup method that takes a context.Context, and call it in the OnStartup
  // of options.App below.  This test wouldn't need it, but I'll put it here for completeness sake
  t.ctx = ctx
}

// Creating the test struct and putting it bind will cause Wails to generate a typescript function HelloWorld that returns Promise<string>
// if the second return is an error type and is not null, the Promise will fail and you can catch it with .catch() on the javascript side
t := &Test{}
err := wails.Run(&options.App{
    OnStartup: func(ctx context.Context) {
        t.startup(ctx)
    },
    Bind: []interface{}{
        t
    },
})

```
```typescript
// frontend/src/test.ts
import { HelloWorld } from "../wailsjs/go/main/test";

export function Test() {
  useEffect(() => {
    (async() => {
      await HelloWorld().then(s => console.log(s)).catch(e=> console.log(e));
    })
  })
}
```
#### Event based communication
The Go backend can also call runtime.EventsEmit to send events to the frontend over a websocket.  You subscribe to these events with the EventsOn method
provided by Wails.  EventsOn returns a function that unsubscribes to the event.

#### Event Example
```go
func HelloWorldEvent(ctx context.Context) {
  // "session.helloworld" is arbitrary, but <module>:<event> seems to be a standard practice.
  // The second argument will be serialized to JSON and sent over the websocket.
  // SessionService has a helper method, emitEvent that you should use that wraps platform.EventsEmit.  This is for testing purposes:
  // the ctx passed to Events.Emit must be the one that comes from the App.Startup callback back in main.
  // emitEvent no-ops if the ctx is invalid, allowing unit testing.  I'll show both here for completeness.
  runtime.EventsEmit(ctx, "session:helloworld", "Hello World!")
  emitEvent("session:helloworld", "Hello World!") // no ctx to emitEvent, it'll get it from the SessionService struct
}
```
```typescript
import { EventsOn } from "../wailsjs/platform";

export function HelloWorlder() {
  useEffect(() => {
    // EventsOn returns the function that unsubscribes, useEffect's return is a function that is run on cleanup/dismount, so this is
    // a convenient patterm
    return EventsOn("session:helloworld", (val: string) => {
      console.log(val)
    });
  })
}
```

### Notes
* State should be used sparingly on the frontend, and should be used for component rendering
or data purposes.  The Go backend should always be the source of truth for the state of the application, fetch it
with bound functions, and subscribe to updates with `EventsOn`.

---
### Session Service
The session service is the primary interface for the frontend to communicate and manipulate the backend systems.
Everything the user can do (Load or edit a split file, subscribe to Timer updates, Split a segment, etc) is represented as an
exported Go method with the SessionService as the receiver.

---
### Hotkey Service/Providers
The Hotkey service is the interface that gets key presses from a Hotkey provider, and then calls public methods on the
Session Service based on what was pressed.  For instance, by default pressing `Space` will call the `Split()` method on the Session Service
which marks the time completed for the current segment, then increments to the next.

Hotkey providers are OS based as they need functions to the underlying Operating System API's to function properly,
and need build tags to prevent them from being compiled on inappropriate platforms.

---
### Timer
The Timer Service is basically just a stopwatch.  It uses Go's monotonic clock to generate startTime-currentTime diffs on a Ticker callback
to get a current duration.  It also has some methods to handle serialization from `string` <-> `time.Duration`.  Generally speaking in Typescript
you'll be working in strings,Go will serialize back and forth as needed, and work internally in `time.Duraion`.  Centisecond precision.
